# Front_Interview 기술 요소

## 1. 프론트엔드 빌드 시스템?
 - 바벨(Babel)
  모든 브라우저가 ES6이상의 최신 자바스크립트 문법을 다 이해할 수 없는 원어민 같은 느낌이다.
  해당 친구들을 위해 친절한 번역기 Babel이 등장한 격이다.

  호환성을 위해서 별도로 코드를 작성할 필요가 없다는 게 장점

  바벨의 동작원리는 3개로
  Parsing(파씽) -> Transforming(변환) - Printing(출력) 3가지의 단계로 이어지며
  코드를 읽고 추상 구문 트리로 변환, 추상 구문 트리를 변경 그리고 그 결과를 출력한다.

  바벨은 파씽과 출력, 플러그인은 변환을 담당한다
  바벨 플러그인은 주로 어떤 코드를 어떻게 변환할지를 담당한다.

  BoilerPlates를 새로 만들면 이해하기 쉬울 듯 하다.

 - 폴리필
  최신 ECMAScript환경을 만들기 위해 코드가 실행되는 환경에 존재하지 않는 빌트인, 메소드 등을 추가하는 역할을 한다.
  바벨은 ES6+ f를 ES5로 변환이 가능한 것들만 변환하는데 Promise같이 ES5에 변환할 수 있는게 없으면 에러가 발생
  이런 경우에 폴리필을 통해 이슈를 해결할 수 있다. -> ES5방식으로 구현을 해 해결한다.

 - Node.js
  JavaScript의 런타임(프로그래밍 언어가 구동되는 환경)이다.
  Read, Eval, Print, Loop 4가지 단계를 통해 런타임을 제공한다.
   Read -> 유저의 입력 값을 받아 메모리에 저장
   Eval -> 입력 값의 평가, 실행
   Print -> Eval로 인해 반환된 값을 출력
   Loop -> 위 3가지 과정을 반복 시킴

   REPL보다는 따로 스크립트 파일을 만들어서 사용함

  - NPM (Node Package Manager)
   Node.js로 만들어진 모듈을 웹에 받아 설치하고 관리해주는 프로그램으로
   Package.json이란 파일에서 목록 및 버전확인이 가능하다.
   이 역시 BoilerPlates를 만들면 자세하게 이해할 수 있다.

  - ESLint, Prettier
   코드의 통일성과 보기 편하게 만들어주는 도구들로 각각의 사용처가 다르다.
   ESLint의 경우에는 자바스크립트 코드에서 발견된 문제 패턴을 식별하기 위한 정적 코드 분석 도구로 문법에 맞게 코드를 짤 수 있도록 도와주는 도구다.
   Prettier의 경우에는 코드 스타일을 정리해주는 도구로 주로 공백 관리에 매우 좋다.

  - 웹 테스크 매니저(Web Task Manager)
   코드를 수정 후 저장하고 브라우저에서 새로고침을 해야만 변경된 내용을 확인할 수 있다. 서비스 개발 중에 html, css, js를 압축, 변환 해주는 과정을 자동화 해주는 도구라고 할 수 있다.
   ex) Grunt, Gulp같은 도구가 주 예제다 (BoilerPlates에 넣어볼 만 할듯 하다)


## 2. WebPack과 모듈 번들러
  - 웹팩이란?
   최신 프론트엔드 프레임워크에서 가장 많이 사용되는 모듈 번들러로 파일 확장자에 맞는 로더에게 위임해서 하나로 묶어주고 최종 배포용 파일을 만들어준다. <script /> 태그가 여러개 있을 경우 순서 보장이 매우 중요하기에 이런 과정도 Webpack에서 처리를 해준다.

  - 모듈 번들러란
   Module Bundler란 웹 애플리케이션을 구성하는 자원(HTML, CSS, JS, Image등)을 모두 각각의 모듈로 보고 이를 조합해 병합된 하나의 결과물로 만들어주는 도구
 
  - Module이란
   프로그래밍 관점에서 특정 기능을 갖는 작은 코드 단위로 키보드를 예로 들면 키를 눌러 키를 입력하는 기능을 가진 키보드라는 파일로 관리하는 하나의 모듈이 된다.
   웹팩에서 이 모듈은 웹 애플리케이션을 구성하는 모든 자원을 의미한다.
 
  - Module Bundling이란?
   웹 애플리케이션을 구성하는 몇십, 몇백개의 자원들을 하나의 파일로 병합, 압축해주는 동작을 모듈 번들링이라고 한다.
   과정은 빌드 -> 번들링 -> 변환 이 3개를 통틀어 모듈 번들링이라고 정의한다


## 3. 브라우저 동작 과정
 - 브라우저의 주요 구성 요소
  
 ![95xfCs0](https://user-images.githubusercontent.com/29947636/147730386-77a66b2a-e224-4d96-a664-14687d17d343.png)
 
  1. 사용자 인터페이스: 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분
  2. 브라우저 엔진: 사용자 인터페이스와 엔진 사이의 동작 제어
  3. 렌더링 엔진: 요청한 컨텐츠 표시 - HTML을 요청 시 HTML과 CSS를 파싱하여 표시해 줌
  4. 통신: HTTP 요청과 같은 네트워크 호출에 사용하며 플랫폼이 독립적이고 각 플랫폼 하부에서 실행된다.
  5. UI 백엔드: 콤보 박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서 OS 사용자 인터페이스 체계를 사용.
  6. 자료 저장소: 모든 종류의 자원을 하드 디스크에 저장
  7. 자바스크립트 해석기

 - 브라우저 렌더링 과정
  기본적으로 트리 구조를 사용하게 됨
   1. HTML 마크업을 처리해 DOM(Document Object Model)을 생성한다
   2. CSS 마크업을 처리해 CSSOM(CSS Object Model)을 생성한다.
   3. DOM트리와 CSSOM 트리를 결합해 렌더링 트리를 생성한다
   4. 렌더링 트리를 배치해 각 노드에 대해 화면에서의 정확한 위치와 크기를 계산한다.
   5. 렌더 트리를 그려 UI 백엔드에서 렌더링 트리의 각 노드를 가로지르며 렌더링 한다.

  해당 과정들은 전부 점진적으로 진행되는 것이 특징이다. 렌더링 엔진은 모든 HTML을 파싱할 떄 까지 기다리지 않고 배치와 그리기 과정을 시작해 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시한다.
  
  - attribute와 property
   attribute: HTML 마크업 요소에서 추가적인 정보를 저장할 때 사용하는 방식인데 주로 key="value" 방식으로 이용이 된다. <div class="test"></div>일 경우에 "test"라는 attribute를 가지고 있게 되는 것이다.
   property: attribute에 대해 HTML DOM트리안에서의 표현이 되며 전의 div를 예시로 하게 될때 "test"라는 attribute는 className이라는 property라는 것을 가지게 된다
 
## 4. 프론트엔드 성능 최적화
 - 페이지 로드 최적화
  1. 블록 차단 리소스 최적화: HTML 파싱 할 때 css나 js를 만나게 되면 HTML파싱을 중단하고 해당 파일을 파싱, 다운로드 후 실행이 되는데 이 과정이 블록 차단 리소스라고 한다. 해당 문제를 방지하기 위해 CSS는 head태그 안에 import를 하고 js는 body 맨 하단에 위치해 해당 블록 차단을 최소화 할 수 있다.
  2. 리소스 용량을 줄이기: JS의 경우에는 필요한 부분만 import하는 것, 불 필요한 코드는 제거, tab size는 2칸으로, 압축 및 난독화로 용량을 최소화하는 방식을 사용하고, css는 간결한 selector, 공통 스타일은 class로 정의해 사용, 이미지는 png보다 jpg, jpeg를 사용하는 방식을 이용한다.
    

## 5. Virtual DOM이란
 - DOM은 객체들을 통해 구조화된 문서를 표현하는 방법으로 트리 형태로 구성되어 특정 노드를 검색, 수정, 제거가 가능합니다. 브라우저 동작은 레이아웃을 구성, 색상 변경 등을 진행하는데 속도가 느려지는데 해당 작업을 가상화해 미리 처리한 다음 한번에 적용하는 방법이 Virtual DOM이라는 것이다.
 - SPA(Single Page Application)의 경우 DOM 조작이 많이 발생하는데 이렇게되면 위 동작이 수십번 반복된다. 즉 변화를 적용하기위해 브라우저가 많이 연산해야한다는 소리고, 전체적인 프로세스를 비효율적으로 만듭니다.
 - VirtualDOM은 VDOM에 먼저 그리고 변화가 생기면 그 변경을 반영하는 방식을 채택해 여러번 반복 과정을 거치지 않게 만들어 연산 횟수를 줄여주는 것이라고 할 수 있다.

 즉 Virtual DOM은 DOM을 추상화한 객체로 DOM의 상태를 먼저 저장해 두고, DOM에 변경이 있을 때만 변경한다. 이를 사용함으로써 DOM의 변경이 일어날 때마다 DOM을 다시 그리는 연산횟수를 줄일 수 있고, 어떤게 변경되고 되지않았는지를 자동으로 파악해주는 장점이 있다.


## 6. 웹 접근성과 시멘틱 마크업 그리고 검색엔진
 - 웹 접근성이란 장애인이나 고령자 분들도 우리처럼 같이 웹을 이용할 수 있게 보장해주는 방식으로 시멘틱 마크업을 통해 의미를 잘 전달해주는 역할을 해줘야한다.
 - header, footer, main, section, article, h1, ul, li, nav를 각각의 의미에 맞게 사용해 코드의 가독성과 화면 판독기로 페이지를 탐색 시 시멘틱 마크업이 푯말로 적용되며, 검색엔진에서는 시멘틱 태그가 중요한 키워드로 간주, 검색엔진에 매우 유리해진다
 - 일반적인 SPA(Single Page Application)은 한번에 자바스크립트 형식으로 불러와 구글이 아닌 다른 네이버나 다음은 인식을 잘 못하는 문제가 있어 Next.js같은 Server Side Rendering을 이용해 검색엔진을 최적화 하거나 시멘틱 마크업으로 표시하는 문제로 해결하고 있다.  


## 7. 함수형 프로그래밍
 - 소프트웨어가 점점 커지면서 복잡하게 엉킨 스파게티 코드를 유지보수 하는 것에 어려움이 생겨 거의 모든 것을 함수로 나눠 문제를 해결하는 기법으로 가독성을 높이고 유지보수를 용이하게 한다.

## 8. Import & Require
 - require은 commonJS에서 사용하는 모듈을 가져올 때 사용한다. 명시적인 선언이 아닌 내보낼 객체마다 선언을 해줘야함
 - require를 대채할 import는 ES6문법부터 사용하기 시작한 방법으로 명시적인 선언들이 가능해졌다.
